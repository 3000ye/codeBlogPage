<!DOCTYPE html>
<html lang="en">
  <head>
	<meta name="generator" content="Hugo 0.123.7">
    <meta charset="utf-8" />
    <meta content="IE=edge,chrome=1" http-equiv="X-UA-Compatible" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1, maximum-scale=1" />
    <title>
      3000ye Code Blog
    </title>
    





  
  

<link
  href="/styles/screen.min.7beabc4f9d9bfe5b57c7a6c83ae4447e5f03bcb05196c65ca8202597024e45db.css"
  rel="stylesheet"
  media="screen"
  integrity="sha256-e&#43;q8T52b/ltXx6bIOuREfl8DvLBRlsZcqCAllwJORds=" />
<link
  href="/styles/print.min.d18444d6ed86c4b57f446a2a0bf25716b1cf940c2ad149915f5bcae09d823c2b.css"
  rel="stylesheet"
  media="print"
  integrity="sha256-0YRE1u2GxLV/RGoqC/JXFrHPlAwq0UmRX1vK4J2CPCs=" />

    




  

<script
  src="/js/index.ed8a1ec413a37196b7e82a66a93dc39e391c391bcac52504ae2eb3e53dfee78f.js"
  integrity="sha256-7YoexBOjcZa36CpmqT3DnjkcORvKxSUEri6z5T3&#43;548="
  defer></script>

    
    <style>
      [x-cloak] {
        display: none !important;
      }
    </style>
  </head>
  <body class="index" x-data="{ navOpen: false }" x-cloak>
    <a
      href="#"
      id="nav-button"
      @click="navOpen = !navOpen"
      :class="{'open': navOpen }">
      <span>
        NAV
        <img src="/images/navbar.png" />
      </span>
    </a>
    <div class="toc-wrapper" :class="{'open': navOpen }">
      
      <img src="/images/CC.png" class="logo"/>

      
        <div class="search" x-data="searchController">
          <input
            x-model.debounce.100ms="query"
            type="search"
            class="search"
            id="input-search"
            placeholder="Search" />
          <ul
            class="search-results visible"
            x-show="results.length > 0"
            x-transition.duration.700ms>
            <template x-for="item in results">
              <li>
                <a x-text="item.title" :href="`#${item.id}`"></a>
              </li>
            </template>
          </ul>
        </div>
      
      
  
  
    
  
  <ul
    id="toc"
    class="toc-list-h1"
    x-data="tocController"
    x-init="load([{&#34;id&#34;:&#34;linked-list&#34;,&#34;level&#34;:1,&#34;sub&#34;:[{&#34;id&#34;:&#34;21-merge-two-sorted-lists&#34;,&#34;level&#34;:2,&#34;sub&#34;:[{&#34;id&#34;:&#34;heading&#34;,&#34;level&#34;:3,&#34;title&#34;:&#34;题面&#34;},{&#34;id&#34;:&#34;heading-1&#34;,&#34;level&#34;:3,&#34;title&#34;:&#34;题解&#34;}],&#34;title&#34;:&#34;21. Merge Two Sorted Lists&#34;},{&#34;id&#34;:&#34;83-remove-duplicates-from-sorted-list&#34;,&#34;level&#34;:2,&#34;sub&#34;:[{&#34;id&#34;:&#34;heading-2&#34;,&#34;level&#34;:3,&#34;title&#34;:&#34;题面&#34;},{&#34;id&#34;:&#34;heading-3&#34;,&#34;level&#34;:3,&#34;title&#34;:&#34;题解&#34;}],&#34;title&#34;:&#34;83. Remove Duplicates from Sorted List&#34;},{&#34;id&#34;:&#34;141-linked-list-cycle&#34;,&#34;level&#34;:2,&#34;sub&#34;:[{&#34;id&#34;:&#34;heading-4&#34;,&#34;level&#34;:3,&#34;title&#34;:&#34;题面&#34;},{&#34;id&#34;:&#34;heading-5&#34;,&#34;level&#34;:3,&#34;title&#34;:&#34;题解&#34;}],&#34;title&#34;:&#34;141. Linked List Cycle&#34;},{&#34;id&#34;:&#34;160-intersection-of-two-linked-lists&#34;,&#34;level&#34;:2,&#34;sub&#34;:[{&#34;id&#34;:&#34;heading-6&#34;,&#34;level&#34;:3,&#34;title&#34;:&#34;题面&#34;},{&#34;id&#34;:&#34;heading-7&#34;,&#34;level&#34;:3,&#34;title&#34;:&#34;题解&#34;}],&#34;title&#34;:&#34;160. Intersection of Two Linked Lists&#34;},{&#34;id&#34;:&#34;203-remove-linked-list-elements&#34;,&#34;level&#34;:2,&#34;sub&#34;:[{&#34;id&#34;:&#34;heading-8&#34;,&#34;level&#34;:3,&#34;title&#34;:&#34;题面&#34;},{&#34;id&#34;:&#34;heading-9&#34;,&#34;level&#34;:3,&#34;title&#34;:&#34;题解&#34;}],&#34;title&#34;:&#34;203. Remove Linked List Elements&#34;}],&#34;title&#34;:&#34;Linked List&#34;},{&#34;id&#34;:&#34;stack&#34;,&#34;level&#34;:1,&#34;sub&#34;:[{&#34;id&#34;:&#34;20-valid-parentheses&#34;,&#34;level&#34;:2,&#34;sub&#34;:[{&#34;id&#34;:&#34;heading-10&#34;,&#34;level&#34;:3,&#34;title&#34;:&#34;题面&#34;},{&#34;id&#34;:&#34;heading-1-1&#34;,&#34;level&#34;:3,&#34;title&#34;:&#34;题解&#34;}],&#34;title&#34;:&#34;20. Valid Parentheses&#34;},{&#34;id&#34;:&#34;225-implement-stack-using-queues&#34;,&#34;level&#34;:2,&#34;sub&#34;:[{&#34;id&#34;:&#34;heading-2-1&#34;,&#34;level&#34;:3,&#34;title&#34;:&#34;题面&#34;},{&#34;id&#34;:&#34;heading-3-1&#34;,&#34;level&#34;:3,&#34;title&#34;:&#34;题解&#34;}],&#34;title&#34;:&#34;225. Implement Stack using Queues&#34;},{&#34;id&#34;:&#34;496-next-greater-element-i&#34;,&#34;level&#34;:2,&#34;sub&#34;:[{&#34;id&#34;:&#34;heading-4-1&#34;,&#34;level&#34;:3,&#34;title&#34;:&#34;题面&#34;},{&#34;id&#34;:&#34;heading-5-1&#34;,&#34;level&#34;:3,&#34;title&#34;:&#34;题解&#34;}],&#34;title&#34;:&#34;496. Next Greater Element I&#34;},{&#34;id&#34;:&#34;682-baseball-game&#34;,&#34;level&#34;:2,&#34;sub&#34;:[{&#34;id&#34;:&#34;heading-6-1&#34;,&#34;level&#34;:3,&#34;title&#34;:&#34;题面&#34;},{&#34;id&#34;:&#34;heading-7-1&#34;,&#34;level&#34;:3,&#34;title&#34;:&#34;题解&#34;}],&#34;title&#34;:&#34;682. Baseball Game&#34;},{&#34;id&#34;:&#34;844-backspace-string-compare&#34;,&#34;level&#34;:2,&#34;sub&#34;:[{&#34;id&#34;:&#34;heading-8-1&#34;,&#34;level&#34;:3,&#34;title&#34;:&#34;题面&#34;},{&#34;id&#34;:&#34;heading-9-1&#34;,&#34;level&#34;:3,&#34;title&#34;:&#34;题解&#34;}],&#34;title&#34;:&#34;844. Backspace String Compare&#34;},{&#34;id&#34;:&#34;1021-remove-outermost-parentheses&#34;,&#34;level&#34;:2,&#34;sub&#34;:[{&#34;id&#34;:&#34;heading-10-1&#34;,&#34;level&#34;:3,&#34;title&#34;:&#34;题面&#34;},{&#34;id&#34;:&#34;heading-11&#34;,&#34;level&#34;:3,&#34;title&#34;:&#34;题解&#34;}],&#34;title&#34;:&#34;1021. Remove Outermost Parentheses&#34;},{&#34;id&#34;:&#34;1047-remove-all-adjacent-duplicates-in-string&#34;,&#34;level&#34;:2,&#34;sub&#34;:[{&#34;id&#34;:&#34;heading-12&#34;,&#34;level&#34;:3,&#34;title&#34;:&#34;题面&#34;},{&#34;id&#34;:&#34;heading-13&#34;,&#34;level&#34;:3,&#34;title&#34;:&#34;题解&#34;}],&#34;title&#34;:&#34;1047. Remove All Adjacent Duplicates In String&#34;},{&#34;id&#34;:&#34;1475-final-prices-with-a-special-discount-in-a-shop&#34;,&#34;level&#34;:2,&#34;sub&#34;:[{&#34;id&#34;:&#34;heading-14&#34;,&#34;level&#34;:3,&#34;title&#34;:&#34;题面&#34;},{&#34;id&#34;:&#34;heading-15&#34;,&#34;level&#34;:3,&#34;title&#34;:&#34;题解&#34;}],&#34;title&#34;:&#34;1475. Final Prices With a Special Discount in a Shop&#34;},{&#34;id&#34;:&#34;1544-make-the-string-great&#34;,&#34;level&#34;:2,&#34;sub&#34;:[{&#34;id&#34;:&#34;heading-16&#34;,&#34;level&#34;:3,&#34;title&#34;:&#34;题面&#34;},{&#34;id&#34;:&#34;heading-17&#34;,&#34;level&#34;:3,&#34;title&#34;:&#34;题解&#34;}],&#34;title&#34;:&#34;1544. Make The String Great&#34;},{&#34;id&#34;:&#34;1598-crawler-log-folder&#34;,&#34;level&#34;:2,&#34;sub&#34;:[{&#34;id&#34;:&#34;heading-18&#34;,&#34;level&#34;:3,&#34;title&#34;:&#34;题面&#34;},{&#34;id&#34;:&#34;heading-19&#34;,&#34;level&#34;:3,&#34;title&#34;:&#34;题解&#34;}],&#34;title&#34;:&#34;1598. Crawler Log Folder&#34;}],&#34;title&#34;:&#34;Stack&#34;},{&#34;id&#34;:&#34;queue&#34;,&#34;level&#34;:1,&#34;sub&#34;:[{&#34;sub&#34;:[]}],&#34;title&#34;:&#34;Queue&#34;}])"
    @scroll.window="onScroll()">
    
    <template x-for="row in rows">
      <li>
        <a
          x-text="row.title"
          @click="click(row)"
          :href="`#${row.id}`"
          class="toc-link"
          x-bind="rowClass(row)"></a>
        
          <ul x-show="row.open" x-bind="transitions()" class="da-toc-list-h2">
            <template x-for="row in row.sub">
              <li>
                <a
                  x-text="row.title"
                  @click="click(row)"
                  :href="`#${row.id}`"
                  class="toc-link"
                  x-bind="rowClass(row)"></a>
                
                  <ul
                    x-show="row.open"
                    x-bind="transitions()"
                    class="toc-list-h3">
                    <template x-for="row in row.sub">
                      <li>
                        <a
                          x-text="row.title"
                          @click="click(row)"
                          :href="`#${row.id}`"
                          class="toc-link"
                          x-bind="rowClass(row)"></a>
                      </li>
                    </template>
                  </ul>
                
              </li>
            </template>
          </ul>
        
      </li>
    </template>
  </ul>

      
      
        <ul class="toc-footer">
          
            <li>
              <a href='https://3000ye.com'>3000ye Blog</a>
            </li>
          
        </ul>
      
      
    </div>
    <div class="page-wrapper">
      <div class="dark-box"></div>
      <div class="content">
        
  
    
  
    
  
    
  
  
    





<h1 id="linked-list">Linked List</h1>




  



<h2 id="21-merge-two-sorted-lists">21. Merge Two Sorted Lists</h2>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">typedef</span> ListNode<span style="color:#f92672">*</span> ListLink;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span> {
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>    ListNode<span style="color:#f92672">*</span> mergeTwoLists(ListNode<span style="color:#f92672">*</span> list1, ListNode<span style="color:#f92672">*</span> list2) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (list1 <span style="color:#f92672">==</span> <span style="color:#66d9ef">nullptr</span>) <span style="color:#66d9ef">return</span> list2;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (list2 <span style="color:#f92672">==</span> <span style="color:#66d9ef">nullptr</span>) <span style="color:#66d9ef">return</span> list1;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 将头节点较小的链表放在 list1
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">if</span> (list1<span style="color:#f92672">-&gt;</span>val <span style="color:#f92672">&gt;</span> list2<span style="color:#f92672">-&gt;</span>val) swap(list1, list2);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 遍历 list2，按大小插入 list1
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">auto</span> ls1 <span style="color:#f92672">=</span> list1, ls2 <span style="color:#f92672">=</span> list2;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">while</span> (ls2 <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nullptr</span>) {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> (ls1<span style="color:#f92672">-&gt;</span>next <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nullptr</span> and ls2<span style="color:#f92672">-&gt;</span>val <span style="color:#f92672">&gt;</span> ls1<span style="color:#f92672">-&gt;</span>next<span style="color:#f92672">-&gt;</span>val) {}
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">else</span> {  <span style="color:#75715e">// 插入节点
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>                ListLink temp <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> ListNode(ls2<span style="color:#f92672">-&gt;</span>val, ls1<span style="color:#f92672">-&gt;</span>next);
</span></span><span style="display:flex;"><span>                ls1<span style="color:#f92672">-&gt;</span>next <span style="color:#f92672">=</span> temp;
</span></span><span style="display:flex;"><span>                ls2 <span style="color:#f92672">=</span> ls2<span style="color:#f92672">-&gt;</span>next;
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            ls1 <span style="color:#f92672">=</span> ls1<span style="color:#f92672">-&gt;</span>next;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> list1;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">typedef</span> ListNode<span style="color:#f92672">*</span> ListLink;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>class Solution {
</span></span><span style="display:flex;"><span>public:
</span></span><span style="display:flex;"><span>    ListNode<span style="color:#f92672">*</span> <span style="color:#a6e22e">mergeTwoLists</span>(ListNode<span style="color:#f92672">*</span> list1, ListNode<span style="color:#f92672">*</span> list2) {
</span></span><span style="display:flex;"><span>        ListLink res <span style="color:#f92672">=</span> new <span style="color:#a6e22e">ListNode</span>(<span style="color:#ae81ff">0</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">auto</span> p <span style="color:#f92672">=</span> res, p1 <span style="color:#f92672">=</span> list1, p2 <span style="color:#f92672">=</span> list2;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">while</span> (p1 and p2) {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> (p1<span style="color:#f92672">-&gt;</span>val <span style="color:#f92672">&lt;</span> p2<span style="color:#f92672">-&gt;</span>val) {
</span></span><span style="display:flex;"><span>                p<span style="color:#f92672">-&gt;</span>next <span style="color:#f92672">=</span> p1;
</span></span><span style="display:flex;"><span>                p1 <span style="color:#f92672">=</span> p1<span style="color:#f92672">-&gt;</span>next;
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>                p<span style="color:#f92672">-&gt;</span>next <span style="color:#f92672">=</span> p2;
</span></span><span style="display:flex;"><span>                p2 <span style="color:#f92672">=</span> p2<span style="color:#f92672">-&gt;</span>next;
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            p <span style="color:#f92672">=</span> p<span style="color:#f92672">-&gt;</span>next;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">while</span> (p1) {
</span></span><span style="display:flex;"><span>            p<span style="color:#f92672">-&gt;</span>next <span style="color:#f92672">=</span> p1;
</span></span><span style="display:flex;"><span>            p1 <span style="color:#f92672">=</span> p1<span style="color:#f92672">-&gt;</span>next;
</span></span><span style="display:flex;"><span>            p <span style="color:#f92672">=</span> p<span style="color:#f92672">-&gt;</span>next;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">while</span> (p2) {
</span></span><span style="display:flex;"><span>            p<span style="color:#f92672">-&gt;</span>next <span style="color:#f92672">=</span> p2;
</span></span><span style="display:flex;"><span>            p2 <span style="color:#f92672">=</span> p2<span style="color:#f92672">-&gt;</span>next;
</span></span><span style="display:flex;"><span>            p <span style="color:#f92672">=</span> p<span style="color:#f92672">-&gt;</span>next;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> res<span style="color:#f92672">-&gt;</span>next;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span> {
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span>:
</span></span><span style="display:flex;"><span>    ListNode<span style="color:#f92672">*</span> mergeTwoLists(ListNode<span style="color:#f92672">*</span> list1, ListNode<span style="color:#f92672">*</span> list2) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (list1 <span style="color:#f92672">==</span> nullptr) <span style="color:#66d9ef">return</span> list2;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (list2 <span style="color:#f92672">==</span> nullptr) <span style="color:#66d9ef">return</span> list1;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (list1<span style="color:#f92672">-&gt;</span>val <span style="color:#f92672">&lt;=</span> list2<span style="color:#f92672">-&gt;</span>val) {
</span></span><span style="display:flex;"><span>			list1<span style="color:#f92672">-&gt;</span>next <span style="color:#f92672">=</span> mergeTwoLists(list1<span style="color:#f92672">-&gt;</span>next, list2);
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">return</span> list1;
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>			list2<span style="color:#f92672">-&gt;</span>next <span style="color:#f92672">=</span> mergeTwoLists(list1, list2<span style="color:#f92672">-&gt;</span>next);
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">return</span> list2;
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div>



  



<h3 id="heading">题面</h3>
<p>有两个链表，其中的节点都按照节点值有序排序，请你将这两个链表合并为一个有序链表。</p>




  



<h3 id="heading-1">题解</h3>
<p><strong>Method One</strong>: 直接法</p>
<ul>
<li>将 <code>head-&gt;val</code> 较小的链表作为 <code>list1</code>，放在前面被插入</li>
<li>遍历 <code>list2</code> 按照 <code>node-&gt;val</code> 的大小依次插入 <code>list1</code></li>
<li>需特判链表为空的情况</li>
</ul>
<p><strong>Method Two</strong>: 双指针</p>
<ul>
<li>构造一个虚拟头节点 <code>res</code>，并创建指针 <code>p</code></li>
<li>分别为两个链表创建指针 <code>p1</code> 和 <code>p2</code></li>
<li>遍历 <code>p1</code> 和 <code>p2</code>，直到有一个走到终点</li>
<li>将没有走完的指针走完</li>
</ul>
<p><strong>Method Three</strong>: 递归</p>
<ul>
<li>思想和直接法一样，只是插入的逻辑有变化</li>
<li>直接法是始终往一个链表插入</li>
<li>递归法是根据当前节点的 <code>val</code> 来判断插入方向</li>
</ul>




  



<h2 id="83-remove-duplicates-from-sorted-list">83. Remove Duplicates from Sorted List</h2>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span> {
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>    ListNode<span style="color:#f92672">*</span> deleteDuplicates(ListNode<span style="color:#f92672">*</span> head) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">auto</span> p <span style="color:#f92672">=</span> head;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">while</span> (p <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nullptr</span> and p<span style="color:#f92672">-&gt;</span>next <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nullptr</span>) {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> (p<span style="color:#f92672">-&gt;</span>val <span style="color:#f92672">==</span> p<span style="color:#f92672">-&gt;</span>next<span style="color:#f92672">-&gt;</span>val) {
</span></span><span style="display:flex;"><span>                p<span style="color:#f92672">-&gt;</span>next <span style="color:#f92672">=</span> p<span style="color:#f92672">-&gt;</span>next<span style="color:#f92672">-&gt;</span>next;
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">else</span> p <span style="color:#f92672">=</span> p<span style="color:#f92672">-&gt;</span>next;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> head;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div>



  



<h3 id="heading-2">题面</h3>
<p>给你一个有序的链表，请删除其中的重复节点。</p>




  



<h3 id="heading-3">题解</h3>
<p><strong>Method One</strong>: 直接法</p>
<ul>
<li>因为链表是有序的，所以直接遍历链表</li>
<li>如果 <code>p-&gt;val == p-&gt;next-&gt;val</code> 则删除 <code>p-&gt;next</code> 节点</li>
<li>否则继续前进</li>
</ul>




  



<h2 id="141-linked-list-cycle">141. Linked List Cycle</h2>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span> {
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">bool</span> hasCycle(ListNode <span style="color:#f92672">*</span>head) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">auto</span> fast <span style="color:#f92672">=</span> head, slow <span style="color:#f92672">=</span> head;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">while</span> (fast and fast<span style="color:#f92672">-&gt;</span>next) {
</span></span><span style="display:flex;"><span>            fast <span style="color:#f92672">=</span> fast<span style="color:#f92672">-&gt;</span>next<span style="color:#f92672">-&gt;</span>next;
</span></span><span style="display:flex;"><span>            slow <span style="color:#f92672">=</span> slow<span style="color:#f92672">-&gt;</span>next;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> (fast <span style="color:#f92672">==</span> slow) <span style="color:#66d9ef">return</span> true;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> false;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span>class Solution {
</span></span><span style="display:flex;"><span>public:
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">bool</span> <span style="color:#a6e22e">hasCycle</span>(ListNode <span style="color:#f92672">*</span>head) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>head) <span style="color:#66d9ef">return</span> false;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> cnt <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">while</span> (cnt <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">10010</span>) {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> (head<span style="color:#f92672">-&gt;</span>next <span style="color:#f92672">==</span> nullptr) <span style="color:#66d9ef">return</span> false;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            head <span style="color:#f92672">=</span> head<span style="color:#f92672">-&gt;</span>next;
</span></span><span style="display:flex;"><span>            cnt <span style="color:#f92672">++</span>;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> true;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div>



  



<h3 id="heading-4">题面</h3>
<p>给你一个链表，请判断链表中是否存在环。</p>




  



<h3 id="heading-5">题解</h3>
<p><strong>Method One</strong>: 快慢指针</p>
<ul>
<li>若链表中存在环，则遍历链表是一个死循环</li>
<li>因此我们构造两个快慢指针 <code>fast</code> 和 <code>slow</code></li>
<li><code>fast</code> 每次前进 2 步，<code>slow</code> 每次前进 1 步</li>
<li>如果存在环，则 <code>fast</code> 和 <code>slow</code> 会相遇</li>
</ul>
<p><strong>Method Two</strong>: 暴力</p>
<ul>
<li>注意到题目的数据量为 <code>1e4</code></li>
<li>因此我们可以直接前进 <code>10010</code> 步，判断是否走到终点</li>
</ul>




  



<h2 id="160-intersection-of-two-linked-lists">160. Intersection of Two Linked Lists</h2>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span> {
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>    ListNode <span style="color:#f92672">*</span>getIntersectionNode(ListNode <span style="color:#f92672">*</span>headA, ListNode <span style="color:#f92672">*</span>headB) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">auto</span> p <span style="color:#f92672">=</span> headA, q <span style="color:#f92672">=</span> headB;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">while</span> (p <span style="color:#f92672">!=</span> q) {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>p) p <span style="color:#f92672">=</span> headB;
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">else</span> p <span style="color:#f92672">=</span> p<span style="color:#f92672">-&gt;</span>next;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>q) q <span style="color:#f92672">=</span> headA;
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">else</span> q <span style="color:#f92672">=</span> q<span style="color:#f92672">-&gt;</span>next;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> p;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div>



  



<h3 id="heading-6">题面</h3>
<p>有两个链表 <code>headA</code> 和 <code>headB</code>，请你找出它们尾部相同的部分。</p>




  



<h3 id="heading-7">题解</h3>
<p><strong>Method One</strong>: 双指针</p>
<ul>
<li><code>headA</code> 和 <code>headB</code> 长度不一致，但是尾部相同</li>
<li>则有 <code>headA = preA + tail</code>， <code>headB = preB + tail</code></li>
<li>即 <code>headA + headB = x + tail</code>，<code>headB + headA = y + tail</code></li>
<li>因此直接找 <code>headA + headB</code> 和 <code>headB + headA</code> 的相同尾部</li>
</ul>




  



<h2 id="203-remove-linked-list-elements">203. Remove Linked List Elements</h2>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span> {
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>    ListNode<span style="color:#f92672">*</span> removeElements(ListNode<span style="color:#f92672">*</span> head, <span style="color:#66d9ef">int</span> val) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">while</span> (head and head<span style="color:#f92672">-&gt;</span>val <span style="color:#f92672">==</span> val) head <span style="color:#f92672">=</span> head<span style="color:#f92672">-&gt;</span>next;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">auto</span> p <span style="color:#f92672">=</span> head;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">while</span> (p and p<span style="color:#f92672">-&gt;</span>next) {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> (p<span style="color:#f92672">-&gt;</span>next<span style="color:#f92672">-&gt;</span>val <span style="color:#f92672">==</span> val) p<span style="color:#f92672">-&gt;</span>next <span style="color:#f92672">=</span> p<span style="color:#f92672">-&gt;</span>next<span style="color:#f92672">-&gt;</span>next;
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">else</span> p <span style="color:#f92672">=</span> p<span style="color:#f92672">-&gt;</span>next;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> head;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div>



  



<h3 id="heading-8">题面</h3>
<p>给你一个链表 <code>head</code> 和一个整数 <code>val</code>，请删除链表中 <code>p-&gt;val == val</code> 的节点。</p>




  



<h3 id="heading-9">题解</h3>
<p><strong>Method One</strong>: 直接法</p>
<ul>
<li>首先特判头节点的值 <code>head-&gt;val</code> 是否等于 <code>val</code></li>
<li>然后遍历链表，将 <code>p-&gt;val == val</code> 的节点删掉</li>
</ul>

  
    



  



<h1 id="stack">Stack</h1>




  



<h2 id="20-valid-parentheses">20. Valid Parentheses</h2>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span> {
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">bool</span> isValid(string s) {
</span></span><span style="display:flex;"><span>        stack<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">char</span><span style="color:#f92672">&gt;</span> stk;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">auto</span> c : s) {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> (stk.size() <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>) stk.push(c);
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">else</span> <span style="color:#a6e22e">if</span> (stk.top() <span style="color:#f92672">==</span> <span style="color:#e6db74">&#39;(&#39;</span> and c <span style="color:#f92672">==</span> <span style="color:#e6db74">&#39;)&#39;</span>) stk.pop();
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">else</span> <span style="color:#a6e22e">if</span> (stk.top() <span style="color:#f92672">==</span> <span style="color:#e6db74">&#39;[&#39;</span> and c <span style="color:#f92672">==</span> <span style="color:#e6db74">&#39;]&#39;</span>) stk.pop();
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">else</span> <span style="color:#a6e22e">if</span> (stk.top() <span style="color:#f92672">==</span> <span style="color:#960050;background-color:#1e0010">&#39;</span>{<span style="color:#960050;background-color:#1e0010">&#39;</span> and c <span style="color:#f92672">==</span> <span style="color:#e6db74">&#39;}&#39;</span>) stk.pop();
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">else</span> stk.push(c);
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> stk.size() <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span> <span style="color:#f92672">?</span> true <span style="color:#f92672">:</span> false;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div>



  
    
      
        
      
    
      
        
      
    
      
        
      
    
      
        
      
    
      
        
      
    
      
        
      
    
      
        
      
    
      
        
      
    
      
        
      
    
      
        
      
    
  



<h3 id="heading-10">题面</h3>
<p>给定一个只包括 <code>'('</code>，<code>')'</code>，<code>'{'</code>，<code>'}'</code>，<code>'['</code>，<code>']'</code> 的字符串 <code>s</code> ，判断字符串是否有效。</p>
<p>有效字符串需满足：</p>
<ol>
<li>左括号必须用相同类型的右括号闭合。</li>
<li>左括号必须以正确的顺序闭合。</li>
<li>每个右括号都有一个对应的相同类型的左括号。</li>
</ol>




  
    
      
        
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
  



<h3 id="heading-1-1">题解</h3>
<p><strong>Method One</strong>: 直接法</p>
<ul>
<li>遍历字符串，如果栈为空则入栈</li>
<li>如果栈不为空，则判断栈头和当前字符是否匹配
<ul>
<li>如果匹配，则栈弹出</li>
<li>否则入栈</li>
</ul>
</li>
<li>最终判断栈是否为空，如果为空则合法</li>
</ul>




  



<h2 id="225-implement-stack-using-queues">225. Implement Stack using Queues</h2>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">MyStack</span> {
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">private</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> stk[<span style="color:#ae81ff">200</span>];
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> head;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>    MyStack() <span style="color:#f92672">:</span> head(<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>) {}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">push</span>(<span style="color:#66d9ef">int</span> x) {
</span></span><span style="display:flex;"><span>        stk[<span style="color:#f92672">++</span> head] <span style="color:#f92672">=</span> x;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">pop</span>() {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> stk[head <span style="color:#f92672">--</span>];
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">top</span>() {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> stk[head];
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">bool</span> <span style="color:#a6e22e">empty</span>() {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> head <span style="color:#f92672">==</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div>



  
    
      
        
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
  



<h3 id="heading-2-1">题面</h3>
<p>给定一个只包括 <code>'('</code>，<code>')'</code>，<code>'{'</code>，<code>'}'</code>，<code>'['</code>，<code>']'</code> 的字符串 <code>s</code> ，判断字符串是否有效。</p>
<p>有效字符串需满足：</p>
<ol>
<li>左括号必须用相同类型的右括号闭合。</li>
<li>左括号必须以正确的顺序闭合。</li>
<li>每个右括号都有一个对应的相同类型的左括号。</li>
</ol>




  
    
      
        
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
  



<h3 id="heading-3-1">题解</h3>
<p><strong>Method One</strong>: 数组模拟</p>
<ul>
<li>数据范围 <code>100</code>，则直接开一个长度足够的数组</li>
<li>通过下标 <code>head</code> 来模拟入栈和弹出等</li>
</ul>




  



<h2 id="496-next-greater-element-i">496. Next Greater Element I</h2>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span> {
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>    vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> nextGreaterElement(vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;&amp;</span> nums1, vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;&amp;</span> nums2) {
</span></span><span style="display:flex;"><span>        stack<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> stk;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> flag[<span style="color:#ae81ff">10010</span>];
</span></span><span style="display:flex;"><span>        memset(flag, <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>, <span style="color:#66d9ef">sizeof</span>(flag));
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">auto</span> i : nums2) {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">while</span> (<span style="color:#f92672">!</span>stk.empty() and stk.top() <span style="color:#f92672">&lt;</span> i) {
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">int</span> x <span style="color:#f92672">=</span> stk.top();
</span></span><span style="display:flex;"><span>                flag[x] <span style="color:#f92672">=</span> i;
</span></span><span style="display:flex;"><span>                stk.pop();
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            stk.push(i);
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> res(nums1.size(), <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>, l <span style="color:#f92672">=</span> nums1.size(); i <span style="color:#f92672">&lt;</span> l; i <span style="color:#f92672">++</span>) {
</span></span><span style="display:flex;"><span>            res[i] <span style="color:#f92672">=</span> flag[nums1[i]];
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> res;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div>



  
    
      
        
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
  



<h3 id="heading-4-1">题面</h3>
<p><code>nums1</code> 中数字 <code>x</code> 的 <strong>下一个更大元素</strong> 是指 <code>x</code> 在 <code>nums2</code> 中对应位置 <strong>右侧</strong> 的 <strong>第一个</strong> 比 <code>x</code> 大的元素。</p>
<p>给你两个 <strong>没有重复元素</strong> 的数组 <code>nums1</code> 和 <code>nums2</code> ，下标从 <strong>0</strong> 开始计数，其中<code>nums1</code> 是 <code>nums2</code> 的子集。</p>
<p>对于每个 <code>0 &lt;= i &lt; nums1.length</code> ，找出满足 <code>nums1[i] == nums2[j]</code> 的下标 <code>j</code> ，并且在 <code>nums2</code> 确定 <code>nums2[j]</code> 的 <strong>下一个更大元素</strong> 。如果不存在下一个更大元素，那么本次查询的答案是 <code>-1</code> 。</p>
<p>返回一个长度为 <code>nums1.length</code> 的数组 <code>ans</code> 作为答案，满足 <code>ans[i]</code> 是如上所述的 <strong>下一个更大元素</strong> 。</p>




  
    
      
        
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
  



<h3 id="heading-5-1">题解</h3>
<p><strong>Method One</strong>: 单调栈</p>
<ul>
<li>我们需要在 <code>nums2</code> 中找到 <code>x</code> 右侧比 <code>x</code> 大的数字 <code>y</code></li>
<li>构造一个单调栈，遍历 <code>nums2</code>，记录被弹出的元素的值 <code>x</code> 和新插入的 <code>y</code></li>
<li>这些元素会被弹出，说明 <code>x</code> 的右侧存在比 <code>x</code> 大的 <code>y</code></li>
<li>最后遍历 <code>nums1</code> 找到每个 <code>x</code> 对应的 <code>y</code></li>
</ul>
<p>注意：需注意数据范围 <code>[0, 1e4]</code> 开足够长的数组和下标的记录。</p>




  



<h2 id="682-baseball-game">682. Baseball Game</h2>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span> {
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> calPoints(vector<span style="color:#f92672">&lt;</span>string<span style="color:#f92672">&gt;&amp;</span> operations) {
</span></span><span style="display:flex;"><span>        stack<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> stk;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">auto</span> s : operations) {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> (s <span style="color:#f92672">==</span> <span style="color:#e6db74">&#34;+&#34;</span>) {
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">int</span> x <span style="color:#f92672">=</span> stk.top(); stk.pop();
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">int</span> y <span style="color:#f92672">=</span> stk.top(); stk.pop();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>                stk.push(y); stk.push(x); stk.push(x <span style="color:#f92672">+</span> y);
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">else</span> <span style="color:#a6e22e">if</span> (s <span style="color:#f92672">==</span> <span style="color:#e6db74">&#34;D&#34;</span>) stk.push(stk.top() <span style="color:#f92672">*</span> <span style="color:#ae81ff">2</span>);
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">else</span> <span style="color:#a6e22e">if</span> (s <span style="color:#f92672">==</span> <span style="color:#e6db74">&#34;C&#34;</span>) stk.pop();
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">else</span> stk.push(std<span style="color:#f92672">::</span>stoi(s));
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> sum <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">while</span> (<span style="color:#f92672">!</span>stk.empty()) {
</span></span><span style="display:flex;"><span>            sum <span style="color:#f92672">+=</span> stk.top();
</span></span><span style="display:flex;"><span>            stk.pop();
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> sum;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div>



  
    
      
        
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
  



<h3 id="heading-6-1">题面</h3>
<p>你现在是一场采用特殊赛制棒球比赛的记录员。这场比赛由若干回合组成，过去几回合的得分可能会影响以后几回合的得分。</p>
<p>比赛开始时，记录是空白的。你会得到一个记录操作的字符串列表 <code>ops</code>，其中 <code>ops[i]</code> 是你需要记录的第 <code>i</code> 项操作，<code>ops</code> 遵循下述规则：</p>
<ol>
<li>整数 <code>x</code> - 表示本回合新获得分数 <code>x</code></li>
<li><code>&quot;+&quot;</code> - 表示本回合新获得的得分是前两次得分的总和。题目数据保证记录此操作时前面总是存在两个有效的分数。</li>
<li><code>&quot;D&quot;</code> - 表示本回合新获得的得分是前一次得分的两倍。题目数据保证记录此操作时前面总是存在一个有效的分数。</li>
<li><code>&quot;C&quot;</code> - 表示前一次得分无效，将其从记录中移除。题目数据保证记录此操作时前面总是存在一个有效的分数。</li>
</ol>
<p>请你返回记录中所有得分的总和。</p>




  
    
      
        
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
  



<h3 id="heading-7-1">题解</h3>
<p><strong>Method One</strong>: 直接法</p>
<ul>
<li>用栈模拟题面的操作</li>
</ul>




  



<h2 id="844-backspace-string-compare">844. Backspace String Compare</h2>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span> {
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">bool</span> backspaceCompare(string s, string t) {
</span></span><span style="display:flex;"><span>        stack<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">char</span><span style="color:#f92672">&gt;</span> x, y;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">auto</span> c : s) {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> (c <span style="color:#f92672">==</span> <span style="color:#e6db74">&#39;#&#39;</span>) {
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>x.empty()) x.pop();
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">else</span> x.push(c);
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">auto</span> c : t) {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> (c <span style="color:#f92672">==</span> <span style="color:#e6db74">&#39;#&#39;</span>) {
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>y.empty()) y.pop();
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">else</span> y.push(c);
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> x <span style="color:#f92672">==</span> y;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div>



  
    
      
        
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
  



<h3 id="heading-8-1">题面</h3>
<p>给定 <code>s</code> 和 <code>t</code> 两个字符串，当它们分别被输入到空白的文本编辑器后，如果两者相等，返回 <code>true</code> 。<code>#</code> 代表退格字符。</p>
<p><strong>注意</strong>：如果对空文本输入退格字符，文本继续为空。</p>




  
    
      
        
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
  



<h3 id="heading-9-1">题解</h3>
<p><strong>Method One</strong>: 直接法</p>
<ul>
<li>遍历字符串，将其文本记录在栈中</li>
<li>判断两个栈是否相等</li>
</ul>




  



<h2 id="1021-remove-outermost-parentheses">1021. Remove Outermost Parentheses</h2>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span> {
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>    string removeOuterParentheses(string s) {
</span></span><span style="display:flex;"><span>        stack<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">char</span><span style="color:#f92672">&gt;</span> stk;
</span></span><span style="display:flex;"><span>        string res;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">auto</span> c : s) {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> (stk.empty()) stk.push(c);
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">if</span> (c <span style="color:#f92672">==</span> <span style="color:#e6db74">&#39;(&#39;</span>) {  <span style="color:#75715e">// stk 必定不为空
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>                    res <span style="color:#f92672">+=</span> c;
</span></span><span style="display:flex;"><span>                    stk.push(c);
</span></span><span style="display:flex;"><span>                }
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>                    stk.pop();
</span></span><span style="display:flex;"><span>                    <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>stk.empty()) res <span style="color:#f92672">+=</span> c;
</span></span><span style="display:flex;"><span>                }
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> res;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div>



  
    
      
        
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
  



<h3 id="heading-10-1">题面</h3>
<p>有效括号字符串为空 <code>&quot;&quot;</code>、<code>&quot;(&quot; + A + &quot;)&quot;</code> 或 <code>A + B</code> ，其中 <code>A</code> 和 <code>B</code> 都是有效的括号字符串，<code>+</code> 代表字符串的连接。</p>
<ul>
<li>例如，<code>&quot;&quot;</code>，<code>&quot;()&quot;</code>，<code>&quot;(())()&quot;</code> 和 <code>&quot;(()(()))&quot;</code> 都是有效的括号字符串。</li>
</ul>
<p>如果有效字符串 <code>s</code> 非空，且不存在将其拆分为 <code>s = A + B</code> 的方法，我们称其为<strong>原语（primitive）</strong>，其中 <code>A</code> 和 <code>B</code> 都是非空有效括号字符串。</p>
<p>给出一个非空有效字符串 <code>s</code>，考虑将其进行原语化分解，使得：<code>s = P_1 + P_2 + ... + P_k</code>，其中 <code>P_i</code> 是有效括号字符串原语。</p>
<p>对 <code>s</code> 进行原语化分解，删除分解中每个原语字符串的最外层括号，返回 <code>s</code> 。</p>




  



<h3 id="heading-11">题解</h3>
<p><strong>Method One</strong>: 直接法</p>
<ul>
<li>使用栈来维护括号的匹配关系，遍历字符串</li>
<li>如果栈为空则直接入栈</li>
<li>如果 <code>c = (</code> ，此时栈不可能为空，入栈，<code>res += c</code></li>
<li>如果 <code>c = )</code> ，栈弹出栈头，此时需判断栈是否为空
<ul>
<li>如果为空，则说明已经走到括号的最外面</li>
<li>否则，<code>res += c</code></li>
</ul>
</li>
</ul>




  



<h2 id="1047-remove-all-adjacent-duplicates-in-string">1047. Remove All Adjacent Duplicates In String</h2>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span> {
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>    string removeDuplicates(string s) {
</span></span><span style="display:flex;"><span>        string res;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">auto</span> c : s) {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> (res.empty()) res.push_back(c);
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">if</span> (res.back() <span style="color:#f92672">==</span> c) {
</span></span><span style="display:flex;"><span>                    <span style="color:#66d9ef">while</span> (<span style="color:#f92672">!</span>res.empty() and res.back() <span style="color:#f92672">==</span> c) res.pop_back();
</span></span><span style="display:flex;"><span>                }
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">else</span> res.push_back(c);
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> res;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div>



  



<h3 id="heading-12">题面</h3>
<p>给出由小写字母组成的字符串 <code>S</code>，<strong>重复项删除操作</strong>会选择两个相邻且相同的字母，并删除它们。</p>
<p>在 <code>S</code> 上反复执行重复项删除操作，直到无法继续删除。</p>
<p>在完成所有重复项删除操作后返回最终的字符串。答案保证唯一。</p>




  



<h3 id="heading-13">题解</h3>
<p><strong>Method One</strong>: 直接法</p>
<ul>
<li>用 <code>string</code> 模拟栈，按题意操作即可</li>
</ul>




  



<h2 id="1475-final-prices-with-a-special-discount-in-a-shop">1475. Final Prices With a Special Discount in a Shop</h2>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">typedef</span> pair<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span>, <span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> pii;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span> {
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>    vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> finalPrices(vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;&amp;</span> prices) {
</span></span><span style="display:flex;"><span>        stack<span style="color:#f92672">&lt;</span>pii<span style="color:#f92672">&gt;</span> stk;  <span style="color:#75715e">// 递增单调栈
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>, l <span style="color:#f92672">=</span> prices.size(); i <span style="color:#f92672">&lt;</span> l; i <span style="color:#f92672">++</span>) {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>stk.empty() and prices[i] <span style="color:#f92672">&lt;=</span> stk.top().first) {
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">while</span> (<span style="color:#f92672">!</span>stk.empty() and prices[i] <span style="color:#f92672">&lt;=</span> stk.top().first) {
</span></span><span style="display:flex;"><span>                    prices[stk.top().second] <span style="color:#f92672">-=</span> prices[i];
</span></span><span style="display:flex;"><span>                    stk.pop();
</span></span><span style="display:flex;"><span>                }
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            stk.push({prices[i], i});
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> prices;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div>



  



<h3 id="heading-14">题面</h3>
<p>给你一个数组 <code>prices</code> ，其中 <code>prices[i]</code> 是商店里第 <code>i</code> 件商品的价格。</p>
<p>商店里正在进行促销活动，如果你要买第 <code>i</code> 件商品，那么你可以得到与 <code>prices[j]</code> 相等的折扣，其中 <code>j</code> 是满足 <code>j &gt; i</code> 且 <code>prices[j] &lt;= prices[i]</code> 的 <strong>最小下标</strong> ，如果没有满足条件的 <code>j</code> ，你将没有任何折扣。</p>
<p>请你返回一个数组，数组中第 <code>i</code> 个元素是折扣后你购买商品 <code>i</code> 最终需要支付的价格。</p>




  



<h3 id="heading-15">题解</h3>
<p><strong>Method One</strong>: 单调栈</p>
<ul>
<li>维护一个递增的单调栈，并使用 <code>pair&lt;value, idx&gt;</code> 记录价格和下标</li>
<li>当有元素弹出时，说明遇到了更小的价格，则修改其价格 <code>prices[idx]</code></li>
</ul>




  



<h2 id="1544-make-the-string-great">1544. Make The String Great</h2>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span> {
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>    string makeGood(string s) {
</span></span><span style="display:flex;"><span>        string stk;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">auto</span> c : s) {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> (stk.empty() or abs(stk.back() <span style="color:#f92672">-</span> c) <span style="color:#f92672">!=</span> <span style="color:#ae81ff">32</span>) stk.push_back(c);
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">else</span> stk.pop_back();
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> stk;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div>



  



<h3 id="heading-16">题面</h3>
<p>给你一个由大小写英文字母组成的字符串 <code>s</code> 。</p>
<p>一个整理好的字符串中，两个相邻字符 <code>s[i]</code> 和 <code>s[i+1]</code>，其中 <code>0&lt;= i &lt;= s.length-2</code> ，要满足如下条件:</p>
<ul>
<li>若 <code>s[i]</code> 是小写字符，则 <code>s[i+1]</code> 不可以是相同的大写字符。</li>
<li>若 <code>s[i]</code> 是大写字符，则 <code>s[i+1]</code> 不可以是相同的小写字符。</li>
</ul>
<p>请你将字符串整理好，每次你都可以从字符串中选出满足上述条件的 <strong>两个相邻</strong> 字符并删除，直到字符串整理好为止。</p>
<p>请返回整理好的 <strong>字符串</strong> 。题目保证在给出的约束条件下，测试样例对应的答案是唯一的。</p>
<p><strong>注意：</strong> 空字符串也属于整理好的字符串，尽管其中没有任何字符。</p>




  



<h3 id="heading-17">题解</h3>
<p><strong>Method One</strong>: 直接法</p>
<ul>
<li>使用 <code>string</code> 来维护答案</li>
<li>遍历 <code>s</code> 时按照题意判断即可</li>
</ul>




  



<h2 id="1598-crawler-log-folder">1598. Crawler Log Folder</h2>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span> {
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> minOperations(vector<span style="color:#f92672">&lt;</span>string<span style="color:#f92672">&gt;&amp;</span> logs) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> cnt <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">auto</span> i : logs) {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> (i <span style="color:#f92672">==</span> <span style="color:#e6db74">&#34;../&#34;</span>) cnt <span style="color:#f92672">=</span> max(<span style="color:#ae81ff">0</span>, <span style="color:#f92672">--</span> cnt);
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">else</span> <span style="color:#a6e22e">if</span> (i <span style="color:#f92672">==</span> <span style="color:#e6db74">&#34;./&#34;</span>) <span style="color:#66d9ef">continue</span>;
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">else</span> cnt <span style="color:#f92672">++</span>;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> cnt;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div>



  



<h3 id="heading-18">题面</h3>
<p>每当用户执行变更文件夹操作时，LeetCode 文件系统都会保存一条日志记录。</p>
<p>下面给出对变更操作的说明：</p>
<ul>
<li><code>&quot;../&quot;</code> ：移动到当前文件夹的父文件夹。如果已经在主文件夹下，则 <strong>继续停留在当前文件夹</strong> 。</li>
<li><code>&quot;./&quot;</code> ：继续停留在当前文件夹**。**</li>
<li><code>&quot;x/&quot;</code> ：移动到名为 <code>x</code> 的子文件夹中。题目数据 <strong>保证总是存在文件夹 <code>x</code></strong> 。</li>
</ul>
<p>给你一个字符串列表 <code>logs</code> ，其中 <code>logs[i]</code> 是用户在 <code>i&lt;sup&gt;th&lt;/sup&gt;</code> 步执行的操作。</p>
<p>文件系统启动时位于主文件夹，然后执行 <code>logs</code> 中的操作。</p>
<p>执行完所有变更文件夹操作后，请你找出 <strong>返回主文件夹所需的最小步数</strong> 。</p>




  



<h3 id="heading-19">题解</h3>
<p><strong>Method One</strong>: 直接法</p>
<ul>
<li>直接按照题面模拟即可</li>
</ul>

  
    



  



<h1 id="queue">Queue</h1>

  

      </div>
      <div class="dark-box">
        
          <div
            class="lang-selector"
            x-data="langController"
            x-init="initLangs([{&#34;key&#34;:&#34;cpp&#34;,&#34;name&#34;:&#34;Method One&#34;},{&#34;key&#34;:&#34;c&#34;,&#34;name&#34;:&#34;Method Two&#34;},{&#34;key&#34;:&#34;java&#34;,&#34;name&#34;:&#34;Method Three&#34;}])">
            <template x-for="(tab, index) in tabs">
              <a
                x-text="tab.name"
                :class="{ 'active': tab.active }"
                @click="changeLanguage(index)"></a>
            </template>
          </div>
        
      </div>
    </div>
    
  </body>
</html>
